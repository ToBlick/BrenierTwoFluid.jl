var documenterSearchIndex = {"docs":
[{"location":"library/","page":"Library","title":"Library","text":"CurrentModule = BrenierTwoFluid","category":"page"},{"location":"library/#BrenierTwoFluid-Library-Functions","page":"Library","title":"BrenierTwoFluid Library Functions","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Modules = [BrenierTwoFluid]","category":"page"},{"location":"library/#BrenierTwoFluid.CostCollection","page":"Library","title":"BrenierTwoFluid.CostCollection","text":"CostCollection\n\nCollection of cost matrices involving two point clouds `X` and `Y`. \n\nFields:\n- `C_xy::CT`: N × M `AbstractMatrix`.\n- `C_yx::CT`: M × N `AbstractMatrix`.\n- `C_xx::CT`: N × N `AbstractMatrix`.\n- `C_yy::CT`: M × M `AbstractMatrix`.\n\n\n\n\n\n","category":"type"},{"location":"library/#BrenierTwoFluid.LazyCost","page":"Library","title":"BrenierTwoFluid.LazyCost","text":"LazyCost\n\nAbstractMatrix type that represents a cost matrix between two point clouds `x` and `y`. The cost matrix is not computed until it is indexed.\n\nFields:\n- `x::AT`: N × d `AbstractArray` of points.\n- `y::AT`: M × d `AbstractArray` of points.\n- `c::FT`: `Callable` scalar cost function `x,y -> c(x,y)`. The default is 1/2 times the squared Euclidean distance.\n\n\n\n\n\n","category":"type"},{"location":"library/#BrenierTwoFluid.LazyGibbsKernel","page":"Library","title":"BrenierTwoFluid.LazyGibbsKernel","text":"LazyGibbsKernel\n\nAbstractMatrix type that represents a Gibbs kernel between two point clouds `x` and `y`. The Gibbs kernel is not computed until it is indexed.\n\nFields:\n- `C::LazyCost`: N × M `LazyCost` matrix.\n- `ε::Base.RefValue`: reference of the Gibbs kernel scale.\n\n\n\n\n\n","category":"type"},{"location":"library/#BrenierTwoFluid.SinkhornBarycenter","page":"Library","title":"BrenierTwoFluid.SinkhornBarycenter","text":"SinkhornBarycenter\n\nRepresents a Sinkhorn barycenter problem.\n\nFields:\n- `ω::Vector{T}`: weights of the input distributions.\n- `Ss::Vector{SinkhornDivergence}`: Sinkhorn divergences between the input distributions and the barycenter.\n- `∇c`: gradient of the cost function.\n- `max_it::Int`: maximum number of iterations. This can be different from the maximum number of iterations of the Sinkhorn divergences, typically it is much smaller.\n- `tol::T`: tolerance for the stopping criterion. This can be different from the tolerance of the Sinkhorn divergences.\n- `δX::AT`: gradient of the barycenter problem with respect to the positions of the particles representing the barycenter.\n\nType parameters:\n- `LOG, SAFE, SYM, ACC`: As in `SinkhornDivergence` and in fact identical to those values of the contained `SinkhornDivergence` objects.\n\n\n\n\n\n","category":"type"},{"location":"library/#BrenierTwoFluid.SinkhornDivergence","page":"Library","title":"BrenierTwoFluid.SinkhornDivergence","text":"SinkhornDivergence\n\nSinkhorn divergence between two probability distributions, represented as `SinkhornVariable`s.\n\nFields:\n- `V1::SinkhornVariable`: first probability distribution.\n- `V2::SinkhornVariable`: second probability distribution.\n- `CC::CostCollection`: collection of cost matrices.\n- `params::SinkhornParameters`: Sinkhorn algorithm parameters.\n\nType parameters:\n- `LOG`: whether or not the Sinkhorn algorithm is performed in the log domain.\n- `SAFE`, `SYM`, `ACC`, `DEB`: as in `SinkhornParameters`.\nDefault: log = anything, safe = true, sym = false, acc = anything, deb = true, lowrank = false\n\n\n\n\n\n","category":"type"},{"location":"library/#BrenierTwoFluid.SinkhornParameters","page":"Library","title":"BrenierTwoFluid.SinkhornParameters","text":"SinkhornParameters\n\nFields:\n- `Δ::T`: maximum value we expect the cost function to take\n- `q::T`: scaling parameter. If ε-scaling is employed, the scale s is reduced by a factor q at each iteration.\n- `η::T`: acceleration parameter. At every iteration, f ← (1-η)f₋ + ηf₊.\n- `crit_it::Int`: after `crit_it` iterations, η is inferred from the change in of the marginal error and updated.\n- `p_η::Int`: the change in marginal from `crit_it - p_η` to `crit_it` is used to infer η.\n- `s::T`: current scale. When no ε-scaling is employed, this is constant and equal to ε.\n- `ε::T`: minimum scale.\n- `p::T`: the proportionality of ε to Δ (e.g. p = 2 for the quadratic cost)\n- `tol::T`: tolerance for the stopping criterion, which is either the marginal error or the change in the dual potentials.\n- `max_it::Int`: maximum number of iterations.\n- `tol_it::Int`: the stopping criterion is checked every `tol_it` iterations.\n\nType parameters:\n- `SAFE`: whether or not the stopping criterion is checked rather than just doing a certain amount of iterations. This is set to `false` only if `tol == Inf`.\n- `SYM`: whether or not the Sinkhorn algorithm is symmetrized, i.e. f ← 0.5f₋ + 0.5f₊.\n- `ACC`: whether or not the Sinkhorn algorithm is accelerated, i.e. f ← (1-η)f₋ + ηf₊.\n- `DEB`: whether or not the Sinkhorn algorithm is debiased, i.e. computing W₂(μ,ν) - (W₂(μ,μ) + W₂(ν,ν))/2.\n\n\n\n\n\n","category":"type"},{"location":"library/#BrenierTwoFluid.SinkhornVariable","page":"Library","title":"BrenierTwoFluid.SinkhornVariable","text":"SinkhornVariable\n\nProbability distribution, represented as a collection of weighted particles, and its associated transport potentials.\n\nFields:\n- `X::AT`: particle positions. `AT` is an N×d AbstractArray with elements of type `T`.\n- `α::VT`: particle weights. `VT` is an N×1 AbstractVector with elements of type `T`.\n- `log_α::VT`: logarithm of the particle weights.\n- `f::VT`: transport potential, i.e. the dual variable associated with the probability distribution ∑ᵢαᵢδ(Xᵢ).\n- `f₋::VT`: cache-like array to store the previous value of `f`.\n- `h::VT`: transport potential for the de-biasing step.\n- `h₋::VT`: cache-like array to store the previous value of `h`.\n- `∇fh::AT`: gradient of `f+h` evaluated at `X`.\n\n\n\n\n\n","category":"type"},{"location":"library/#BrenierTwoFluid.compute!-Tuple{SinkhornDivergence{LOG, true} where LOG}","page":"Library","title":"BrenierTwoFluid.compute!","text":"compute!\n\nSolve the OT problem by performing Sinkhorn interations. If `S` is safe, the stopping criterion is checked rather than just doing a certain amount of iterations.\n\nArguments:\n- `S::SinkhornDivergence`\n\nReturns:\n- `value(S)`: the value of the Sinkhorn divergence.\n\n\n\n\n\n","category":"method"},{"location":"library/#BrenierTwoFluid.marginal_error-Tuple{SinkhornDivergence{true}}","page":"Library","title":"BrenierTwoFluid.marginal_error","text":"marginal_errors\n\nCompute the second marginal error of the transport plan associated with `S`, ``\\sum_j \\pi_{ij} - α_i``, in the maximum norm.\n\nArguments:\n- `S::SinkhornDivergence`\n\nReturns:\n- `π2_err`\n\n\n\n\n\n","category":"method"},{"location":"library/#BrenierTwoFluid.marginal_errors-Tuple{SinkhornDivergence{true}}","page":"Library","title":"BrenierTwoFluid.marginal_errors","text":"marginal_errors\n\nCompute the marginal errors of the transport plan associated with `S`,``\\sum_i \\pi_{ij} - β_j`` and ``\\sum_j \\pi_{ij} - α_i``, in the maximum norm.\n\nArguments:\n- `S::SinkhornDivergence`\n\nReturns:\n- `(π1_err, π2_err)`\n\n\n\n\n\n","category":"method"},{"location":"library/#BrenierTwoFluid.sinkhorn_step!-Tuple{SinkhornDivergence{true, SAFE, true} where SAFE}","page":"Library","title":"BrenierTwoFluid.sinkhorn_step!","text":"sinkhorn_step!\n\nPerform one iteration of the Sinkhorn algorithm, i.e. an update on both dual potentials as well as the two de-biasing potentials. This method dispatches to the correct implementation (log, safe, symmetric, accelerated) based on the type of `S`.\n\nArguments:\n- `S::SinkhornDivergence`\n\n\n\n\n\n","category":"method"},{"location":"library/#BrenierTwoFluid.softmin-Union{Tuple{T}, Tuple{Int64, AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, T}} where T","page":"Library","title":"BrenierTwoFluid.softmin","text":"softmin\n\nCompute the softmin of `C[:,j] - f`, i.e. ``\\log \\sum_i α_i exp((f_i - C_{ij})/ε)`` in a numerically stable way (https://www.nowozin.net/sebastian/blog/streaming-log-sum-exp-computation.html).\n\nArguments:\n- `j::Int`: index of the column of `C` we are interested in.\n- `C::AbstractMatrix{T}`: cost matrix.\n- `f::AbstractVector{T}`: dual potential.\n- `log_α::AbstractVector{T}`: logarithm of the weights.\n- `ε::T`: scaling parameter.\n\n\n\n\n\n","category":"method"},{"location":"library/#BrenierTwoFluid.value-Tuple{SinkhornDivergence{true}}","page":"Library","title":"BrenierTwoFluid.value","text":"value\n\nCompute the value of the Sinkhorn divergence associated with `S`, ``\\sum_i α_i (f^\\alpha_i - h^\\alpha_i) + \\sum_j β_j (f^\\beta_j - h^\\beta_j)``.\n\nArguments:\n- `S::SinkhornDivergence`\n\nReturns:\n- `value(S)`\n\n\n\n\n\n","category":"method"},{"location":"library/#BrenierTwoFluid.y_gradient!-Tuple{SinkhornDivergence{true}, Any}","page":"Library","title":"BrenierTwoFluid.y_gradient!","text":"y_gradient!\n\nCompute the gradient of the Sinkhorn divergence with respect to the second probability distribution particle positions, divided by their weights, and store it in `S.V2.∇fh`.\n\nArguments:\n- `S::SinkhornDivergence`\n\nReturns:\n- `∇S`: A reference to `S.V2.∇fh`.\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = BrenierTwoFluid","category":"page"},{"location":"#BrenierTwoFluid","page":"Home","title":"BrenierTwoFluid","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
